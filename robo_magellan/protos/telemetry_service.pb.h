// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: telemetry_service.proto

#ifndef PROTOBUF_telemetry_5fservice_2eproto__INCLUDED
#define PROTOBUF_telemetry_5fservice_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_telemetry_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAttitudeQRequestImpl();
void InitDefaultsAttitudeQRequest();
void InitDefaultsAttitudeQResponseImpl();
void InitDefaultsAttitudeQResponse();
void InitDefaultsHitEventImpl();
void InitDefaultsHitEvent();
void InitDefaultsHeadingAngleImpl();
void InitDefaultsHeadingAngle();
void InitDefaultsEventBaseImpl();
void InitDefaultsEventBase();
void InitDefaultsEventResponseImpl();
void InitDefaultsEventResponse();
void InitDefaultsHeadingEventImpl();
void InitDefaultsHeadingEvent();
void InitDefaultsWaypointImpl();
void InitDefaultsWaypoint();
void InitDefaultsWaypointsImpl();
void InitDefaultsWaypoints();
void InitDefaultsNoContentImpl();
void InitDefaultsNoContent();
inline void InitDefaults() {
  InitDefaultsAttitudeQRequest();
  InitDefaultsAttitudeQResponse();
  InitDefaultsHitEvent();
  InitDefaultsHeadingAngle();
  InitDefaultsEventBase();
  InitDefaultsEventResponse();
  InitDefaultsHeadingEvent();
  InitDefaultsWaypoint();
  InitDefaultsWaypoints();
  InitDefaultsNoContent();
}
}  // namespace protobuf_telemetry_5fservice_2eproto
namespace telemetry {
class AttitudeQRequest;
class AttitudeQRequestDefaultTypeInternal;
extern AttitudeQRequestDefaultTypeInternal _AttitudeQRequest_default_instance_;
class AttitudeQResponse;
class AttitudeQResponseDefaultTypeInternal;
extern AttitudeQResponseDefaultTypeInternal _AttitudeQResponse_default_instance_;
class EventBase;
class EventBaseDefaultTypeInternal;
extern EventBaseDefaultTypeInternal _EventBase_default_instance_;
class EventResponse;
class EventResponseDefaultTypeInternal;
extern EventResponseDefaultTypeInternal _EventResponse_default_instance_;
class HeadingAngle;
class HeadingAngleDefaultTypeInternal;
extern HeadingAngleDefaultTypeInternal _HeadingAngle_default_instance_;
class HeadingEvent;
class HeadingEventDefaultTypeInternal;
extern HeadingEventDefaultTypeInternal _HeadingEvent_default_instance_;
class HitEvent;
class HitEventDefaultTypeInternal;
extern HitEventDefaultTypeInternal _HitEvent_default_instance_;
class NoContent;
class NoContentDefaultTypeInternal;
extern NoContentDefaultTypeInternal _NoContent_default_instance_;
class Waypoint;
class WaypointDefaultTypeInternal;
extern WaypointDefaultTypeInternal _Waypoint_default_instance_;
class Waypoints;
class WaypointsDefaultTypeInternal;
extern WaypointsDefaultTypeInternal _Waypoints_default_instance_;
}  // namespace telemetry
namespace telemetry {

enum Priority {
  UNKNOWN_PRIORITY = 0,
  HIGH = 1,
  MED = 50,
  LOW = 100,
  Priority_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Priority_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Priority_IsValid(int value);
const Priority Priority_MIN = UNKNOWN_PRIORITY;
const Priority Priority_MAX = LOW;
const int Priority_ARRAYSIZE = Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* Priority_descriptor();
inline const ::std::string& Priority_Name(Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    Priority_descriptor(), value);
}
inline bool Priority_Parse(
    const ::std::string& name, Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Priority>(
    Priority_descriptor(), name, value);
}
enum Source {
  UNKNOWN_SOURCE = 0,
  RGBD_CAMERA_FRONT = 1,
  HCSR04_SENSOR_FRONT = 2,
  DEPTH_CAMERA_FRONT = 3,
  Source_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Source_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Source_IsValid(int value);
const Source Source_MIN = UNKNOWN_SOURCE;
const Source Source_MAX = DEPTH_CAMERA_FRONT;
const int Source_ARRAYSIZE = Source_MAX + 1;

const ::google::protobuf::EnumDescriptor* Source_descriptor();
inline const ::std::string& Source_Name(Source value) {
  return ::google::protobuf::internal::NameOfEnum(
    Source_descriptor(), value);
}
inline bool Source_Parse(
    const ::std::string& name, Source* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Source>(
    Source_descriptor(), name, value);
}
// ===================================================================

class AttitudeQRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.AttitudeQRequest) */ {
 public:
  AttitudeQRequest();
  virtual ~AttitudeQRequest();

  AttitudeQRequest(const AttitudeQRequest& from);

  inline AttitudeQRequest& operator=(const AttitudeQRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttitudeQRequest(AttitudeQRequest&& from) noexcept
    : AttitudeQRequest() {
    *this = ::std::move(from);
  }

  inline AttitudeQRequest& operator=(AttitudeQRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttitudeQRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttitudeQRequest* internal_default_instance() {
    return reinterpret_cast<const AttitudeQRequest*>(
               &_AttitudeQRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AttitudeQRequest* other);
  friend void swap(AttitudeQRequest& a, AttitudeQRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttitudeQRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  AttitudeQRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttitudeQRequest& from);
  void MergeFrom(const AttitudeQRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttitudeQRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:telemetry.AttitudeQRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsAttitudeQRequestImpl();
};
// -------------------------------------------------------------------

class AttitudeQResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.AttitudeQResponse) */ {
 public:
  AttitudeQResponse();
  virtual ~AttitudeQResponse();

  AttitudeQResponse(const AttitudeQResponse& from);

  inline AttitudeQResponse& operator=(const AttitudeQResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AttitudeQResponse(AttitudeQResponse&& from) noexcept
    : AttitudeQResponse() {
    *this = ::std::move(from);
  }

  inline AttitudeQResponse& operator=(AttitudeQResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AttitudeQResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttitudeQResponse* internal_default_instance() {
    return reinterpret_cast<const AttitudeQResponse*>(
               &_AttitudeQResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AttitudeQResponse* other);
  friend void swap(AttitudeQResponse& a, AttitudeQResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AttitudeQResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AttitudeQResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AttitudeQResponse& from);
  void MergeFrom(const AttitudeQResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AttitudeQResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float Qc = 1;
  void clear_qc();
  static const int kQcFieldNumber = 1;
  float qc() const;
  void set_qc(float value);

  // float Qx = 2;
  void clear_qx();
  static const int kQxFieldNumber = 2;
  float qx() const;
  void set_qx(float value);

  // float Qy = 3;
  void clear_qy();
  static const int kQyFieldNumber = 3;
  float qy() const;
  void set_qy(float value);

  // float Qz = 4;
  void clear_qz();
  static const int kQzFieldNumber = 4;
  float qz() const;
  void set_qz(float value);

  // uint64 timestamp = 5;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:telemetry.AttitudeQResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float qc_;
  float qx_;
  float qy_;
  float qz_;
  ::google::protobuf::uint64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsAttitudeQResponseImpl();
};
// -------------------------------------------------------------------

class HitEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.HitEvent) */ {
 public:
  HitEvent();
  virtual ~HitEvent();

  HitEvent(const HitEvent& from);

  inline HitEvent& operator=(const HitEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HitEvent(HitEvent&& from) noexcept
    : HitEvent() {
    *this = ::std::move(from);
  }

  inline HitEvent& operator=(HitEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HitEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HitEvent* internal_default_instance() {
    return reinterpret_cast<const HitEvent*>(
               &_HitEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(HitEvent* other);
  friend void swap(HitEvent& a, HitEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HitEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  HitEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HitEvent& from);
  void MergeFrom(const HitEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HitEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // int32 priority = 2;
  void clear_priority();
  static const int kPriorityFieldNumber = 2;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:telemetry.HitEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 priority_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsHitEventImpl();
};
// -------------------------------------------------------------------

class HeadingAngle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.HeadingAngle) */ {
 public:
  HeadingAngle();
  virtual ~HeadingAngle();

  HeadingAngle(const HeadingAngle& from);

  inline HeadingAngle& operator=(const HeadingAngle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadingAngle(HeadingAngle&& from) noexcept
    : HeadingAngle() {
    *this = ::std::move(from);
  }

  inline HeadingAngle& operator=(HeadingAngle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadingAngle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadingAngle* internal_default_instance() {
    return reinterpret_cast<const HeadingAngle*>(
               &_HeadingAngle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(HeadingAngle* other);
  friend void swap(HeadingAngle& a, HeadingAngle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadingAngle* New() const PROTOBUF_FINAL { return New(NULL); }

  HeadingAngle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeadingAngle& from);
  void MergeFrom(const HeadingAngle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeadingAngle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float yaw = 1;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  float yaw() const;
  void set_yaw(float value);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // @@protoc_insertion_point(class_scope:telemetry.HeadingAngle)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float yaw_;
  float pitch_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsHeadingAngleImpl();
};
// -------------------------------------------------------------------

class EventBase : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.EventBase) */ {
 public:
  EventBase();
  virtual ~EventBase();

  EventBase(const EventBase& from);

  inline EventBase& operator=(const EventBase& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventBase(EventBase&& from) noexcept
    : EventBase() {
    *this = ::std::move(from);
  }

  inline EventBase& operator=(EventBase&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventBase& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventBase* internal_default_instance() {
    return reinterpret_cast<const EventBase*>(
               &_EventBase_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(EventBase* other);
  friend void swap(EventBase& a, EventBase& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventBase* New() const PROTOBUF_FINAL { return New(NULL); }

  EventBase* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventBase& from);
  void MergeFrom(const EventBase& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventBase* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry.Source source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::telemetry::Source source() const;
  void set_source(::telemetry::Source value);

  // int32 priority = 2;
  void clear_priority();
  static const int kPriorityFieldNumber = 2;
  ::google::protobuf::int32 priority() const;
  void set_priority(::google::protobuf::int32 value);

  // uint64 timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:telemetry.EventBase)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int source_;
  ::google::protobuf::int32 priority_;
  ::google::protobuf::uint64 timestamp_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsEventBaseImpl();
};
// -------------------------------------------------------------------

class EventResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.EventResponse) */ {
 public:
  EventResponse();
  virtual ~EventResponse();

  EventResponse(const EventResponse& from);

  inline EventResponse& operator=(const EventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EventResponse(EventResponse&& from) noexcept
    : EventResponse() {
    *this = ::std::move(from);
  }

  inline EventResponse& operator=(EventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EventResponse* internal_default_instance() {
    return reinterpret_cast<const EventResponse*>(
               &_EventResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(EventResponse* other);
  friend void swap(EventResponse& a, EventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EventResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  EventResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EventResponse& from);
  void MergeFrom(const EventResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 timestamp = 2;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // .telemetry.Source source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::telemetry::Source source() const;
  void set_source(::telemetry::Source value);

  // @@protoc_insertion_point(class_scope:telemetry.EventResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 timestamp_;
  int source_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsEventResponseImpl();
};
// -------------------------------------------------------------------

class HeadingEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.HeadingEvent) */ {
 public:
  HeadingEvent();
  virtual ~HeadingEvent();

  HeadingEvent(const HeadingEvent& from);

  inline HeadingEvent& operator=(const HeadingEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadingEvent(HeadingEvent&& from) noexcept
    : HeadingEvent() {
    *this = ::std::move(from);
  }

  inline HeadingEvent& operator=(HeadingEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadingEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeadingEvent* internal_default_instance() {
    return reinterpret_cast<const HeadingEvent*>(
               &_HeadingEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(HeadingEvent* other);
  friend void swap(HeadingEvent& a, HeadingEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadingEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  HeadingEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeadingEvent& from);
  void MergeFrom(const HeadingEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeadingEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .telemetry.EventBase base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::telemetry::EventBase& base() const;
  ::telemetry::EventBase* release_base();
  ::telemetry::EventBase* mutable_base();
  void set_allocated_base(::telemetry::EventBase* base);

  // .telemetry.HeadingAngle relativeAngleRadians = 2;
  bool has_relativeangleradians() const;
  void clear_relativeangleradians();
  static const int kRelativeAngleRadiansFieldNumber = 2;
  const ::telemetry::HeadingAngle& relativeangleradians() const;
  ::telemetry::HeadingAngle* release_relativeangleradians();
  ::telemetry::HeadingAngle* mutable_relativeangleradians();
  void set_allocated_relativeangleradians(::telemetry::HeadingAngle* relativeangleradians);

  // float distance = 3;
  void clear_distance();
  static const int kDistanceFieldNumber = 3;
  float distance() const;
  void set_distance(float value);

  // @@protoc_insertion_point(class_scope:telemetry.HeadingEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::telemetry::EventBase* base_;
  ::telemetry::HeadingAngle* relativeangleradians_;
  float distance_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsHeadingEventImpl();
};
// -------------------------------------------------------------------

class Waypoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.Waypoint) */ {
 public:
  Waypoint();
  virtual ~Waypoint();

  Waypoint(const Waypoint& from);

  inline Waypoint& operator=(const Waypoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Waypoint(Waypoint&& from) noexcept
    : Waypoint() {
    *this = ::std::move(from);
  }

  inline Waypoint& operator=(Waypoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Waypoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waypoint* internal_default_instance() {
    return reinterpret_cast<const Waypoint*>(
               &_Waypoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Waypoint* other);
  friend void swap(Waypoint& a, Waypoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Waypoint* New() const PROTOBUF_FINAL { return New(NULL); }

  Waypoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Waypoint& from);
  void MergeFrom(const Waypoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Waypoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float longitude = 1;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // float latitude = 2;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // @@protoc_insertion_point(class_scope:telemetry.Waypoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float longitude_;
  float latitude_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsWaypointImpl();
};
// -------------------------------------------------------------------

class Waypoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.Waypoints) */ {
 public:
  Waypoints();
  virtual ~Waypoints();

  Waypoints(const Waypoints& from);

  inline Waypoints& operator=(const Waypoints& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Waypoints(Waypoints&& from) noexcept
    : Waypoints() {
    *this = ::std::move(from);
  }

  inline Waypoints& operator=(Waypoints&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Waypoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Waypoints* internal_default_instance() {
    return reinterpret_cast<const Waypoints*>(
               &_Waypoints_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Waypoints* other);
  friend void swap(Waypoints& a, Waypoints& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Waypoints* New() const PROTOBUF_FINAL { return New(NULL); }

  Waypoints* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Waypoints& from);
  void MergeFrom(const Waypoints& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Waypoints* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .telemetry.Waypoint elements = 1;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 1;
  const ::telemetry::Waypoint& elements(int index) const;
  ::telemetry::Waypoint* mutable_elements(int index);
  ::telemetry::Waypoint* add_elements();
  ::google::protobuf::RepeatedPtrField< ::telemetry::Waypoint >*
      mutable_elements();
  const ::google::protobuf::RepeatedPtrField< ::telemetry::Waypoint >&
      elements() const;

  // @@protoc_insertion_point(class_scope:telemetry.Waypoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::telemetry::Waypoint > elements_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsWaypointsImpl();
};
// -------------------------------------------------------------------

class NoContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:telemetry.NoContent) */ {
 public:
  NoContent();
  virtual ~NoContent();

  NoContent(const NoContent& from);

  inline NoContent& operator=(const NoContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NoContent(NoContent&& from) noexcept
    : NoContent() {
    *this = ::std::move(from);
  }

  inline NoContent& operator=(NoContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NoContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NoContent* internal_default_instance() {
    return reinterpret_cast<const NoContent*>(
               &_NoContent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(NoContent* other);
  friend void swap(NoContent& a, NoContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NoContent* New() const PROTOBUF_FINAL { return New(NULL); }

  NoContent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NoContent& from);
  void MergeFrom(const NoContent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NoContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:telemetry.NoContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_telemetry_5fservice_2eproto::TableStruct;
  friend void ::protobuf_telemetry_5fservice_2eproto::InitDefaultsNoContentImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AttitudeQRequest

// -------------------------------------------------------------------

// AttitudeQResponse

// float Qc = 1;
inline void AttitudeQResponse::clear_qc() {
  qc_ = 0;
}
inline float AttitudeQResponse::qc() const {
  // @@protoc_insertion_point(field_get:telemetry.AttitudeQResponse.Qc)
  return qc_;
}
inline void AttitudeQResponse::set_qc(float value) {
  
  qc_ = value;
  // @@protoc_insertion_point(field_set:telemetry.AttitudeQResponse.Qc)
}

// float Qx = 2;
inline void AttitudeQResponse::clear_qx() {
  qx_ = 0;
}
inline float AttitudeQResponse::qx() const {
  // @@protoc_insertion_point(field_get:telemetry.AttitudeQResponse.Qx)
  return qx_;
}
inline void AttitudeQResponse::set_qx(float value) {
  
  qx_ = value;
  // @@protoc_insertion_point(field_set:telemetry.AttitudeQResponse.Qx)
}

// float Qy = 3;
inline void AttitudeQResponse::clear_qy() {
  qy_ = 0;
}
inline float AttitudeQResponse::qy() const {
  // @@protoc_insertion_point(field_get:telemetry.AttitudeQResponse.Qy)
  return qy_;
}
inline void AttitudeQResponse::set_qy(float value) {
  
  qy_ = value;
  // @@protoc_insertion_point(field_set:telemetry.AttitudeQResponse.Qy)
}

// float Qz = 4;
inline void AttitudeQResponse::clear_qz() {
  qz_ = 0;
}
inline float AttitudeQResponse::qz() const {
  // @@protoc_insertion_point(field_get:telemetry.AttitudeQResponse.Qz)
  return qz_;
}
inline void AttitudeQResponse::set_qz(float value) {
  
  qz_ = value;
  // @@protoc_insertion_point(field_set:telemetry.AttitudeQResponse.Qz)
}

// uint64 timestamp = 5;
inline void AttitudeQResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AttitudeQResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:telemetry.AttitudeQResponse.timestamp)
  return timestamp_;
}
inline void AttitudeQResponse::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:telemetry.AttitudeQResponse.timestamp)
}

// -------------------------------------------------------------------

// HitEvent

// uint64 timestamp = 1;
inline void HitEvent::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HitEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:telemetry.HitEvent.timestamp)
  return timestamp_;
}
inline void HitEvent::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:telemetry.HitEvent.timestamp)
}

// int32 priority = 2;
inline void HitEvent::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 HitEvent::priority() const {
  // @@protoc_insertion_point(field_get:telemetry.HitEvent.priority)
  return priority_;
}
inline void HitEvent::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:telemetry.HitEvent.priority)
}

// -------------------------------------------------------------------

// HeadingAngle

// float yaw = 1;
inline void HeadingAngle::clear_yaw() {
  yaw_ = 0;
}
inline float HeadingAngle::yaw() const {
  // @@protoc_insertion_point(field_get:telemetry.HeadingAngle.yaw)
  return yaw_;
}
inline void HeadingAngle::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:telemetry.HeadingAngle.yaw)
}

// float pitch = 2;
inline void HeadingAngle::clear_pitch() {
  pitch_ = 0;
}
inline float HeadingAngle::pitch() const {
  // @@protoc_insertion_point(field_get:telemetry.HeadingAngle.pitch)
  return pitch_;
}
inline void HeadingAngle::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:telemetry.HeadingAngle.pitch)
}

// -------------------------------------------------------------------

// EventBase

// .telemetry.Source source = 1;
inline void EventBase::clear_source() {
  source_ = 0;
}
inline ::telemetry::Source EventBase::source() const {
  // @@protoc_insertion_point(field_get:telemetry.EventBase.source)
  return static_cast< ::telemetry::Source >(source_);
}
inline void EventBase::set_source(::telemetry::Source value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:telemetry.EventBase.source)
}

// int32 priority = 2;
inline void EventBase::clear_priority() {
  priority_ = 0;
}
inline ::google::protobuf::int32 EventBase::priority() const {
  // @@protoc_insertion_point(field_get:telemetry.EventBase.priority)
  return priority_;
}
inline void EventBase::set_priority(::google::protobuf::int32 value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:telemetry.EventBase.priority)
}

// uint64 timestamp = 3;
inline void EventBase::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EventBase::timestamp() const {
  // @@protoc_insertion_point(field_get:telemetry.EventBase.timestamp)
  return timestamp_;
}
inline void EventBase::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:telemetry.EventBase.timestamp)
}

// -------------------------------------------------------------------

// EventResponse

// .telemetry.Source source = 1;
inline void EventResponse::clear_source() {
  source_ = 0;
}
inline ::telemetry::Source EventResponse::source() const {
  // @@protoc_insertion_point(field_get:telemetry.EventResponse.source)
  return static_cast< ::telemetry::Source >(source_);
}
inline void EventResponse::set_source(::telemetry::Source value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:telemetry.EventResponse.source)
}

// uint64 timestamp = 2;
inline void EventResponse::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EventResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:telemetry.EventResponse.timestamp)
  return timestamp_;
}
inline void EventResponse::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:telemetry.EventResponse.timestamp)
}

// -------------------------------------------------------------------

// HeadingEvent

// .telemetry.EventBase base = 1;
inline bool HeadingEvent::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void HeadingEvent::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) {
    delete base_;
  }
  base_ = NULL;
}
inline const ::telemetry::EventBase& HeadingEvent::base() const {
  const ::telemetry::EventBase* p = base_;
  // @@protoc_insertion_point(field_get:telemetry.HeadingEvent.base)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry::EventBase*>(
      &::telemetry::_EventBase_default_instance_);
}
inline ::telemetry::EventBase* HeadingEvent::release_base() {
  // @@protoc_insertion_point(field_release:telemetry.HeadingEvent.base)
  
  ::telemetry::EventBase* temp = base_;
  base_ = NULL;
  return temp;
}
inline ::telemetry::EventBase* HeadingEvent::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::telemetry::EventBase;
  }
  // @@protoc_insertion_point(field_mutable:telemetry.HeadingEvent.base)
  return base_;
}
inline void HeadingEvent::set_allocated_base(::telemetry::EventBase* base) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_;
  }
  if (base) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    
  } else {
    
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:telemetry.HeadingEvent.base)
}

// .telemetry.HeadingAngle relativeAngleRadians = 2;
inline bool HeadingEvent::has_relativeangleradians() const {
  return this != internal_default_instance() && relativeangleradians_ != NULL;
}
inline void HeadingEvent::clear_relativeangleradians() {
  if (GetArenaNoVirtual() == NULL && relativeangleradians_ != NULL) {
    delete relativeangleradians_;
  }
  relativeangleradians_ = NULL;
}
inline const ::telemetry::HeadingAngle& HeadingEvent::relativeangleradians() const {
  const ::telemetry::HeadingAngle* p = relativeangleradians_;
  // @@protoc_insertion_point(field_get:telemetry.HeadingEvent.relativeAngleRadians)
  return p != NULL ? *p : *reinterpret_cast<const ::telemetry::HeadingAngle*>(
      &::telemetry::_HeadingAngle_default_instance_);
}
inline ::telemetry::HeadingAngle* HeadingEvent::release_relativeangleradians() {
  // @@protoc_insertion_point(field_release:telemetry.HeadingEvent.relativeAngleRadians)
  
  ::telemetry::HeadingAngle* temp = relativeangleradians_;
  relativeangleradians_ = NULL;
  return temp;
}
inline ::telemetry::HeadingAngle* HeadingEvent::mutable_relativeangleradians() {
  
  if (relativeangleradians_ == NULL) {
    relativeangleradians_ = new ::telemetry::HeadingAngle;
  }
  // @@protoc_insertion_point(field_mutable:telemetry.HeadingEvent.relativeAngleRadians)
  return relativeangleradians_;
}
inline void HeadingEvent::set_allocated_relativeangleradians(::telemetry::HeadingAngle* relativeangleradians) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relativeangleradians_;
  }
  if (relativeangleradians) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relativeangleradians = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relativeangleradians, submessage_arena);
    }
    
  } else {
    
  }
  relativeangleradians_ = relativeangleradians;
  // @@protoc_insertion_point(field_set_allocated:telemetry.HeadingEvent.relativeAngleRadians)
}

// float distance = 3;
inline void HeadingEvent::clear_distance() {
  distance_ = 0;
}
inline float HeadingEvent::distance() const {
  // @@protoc_insertion_point(field_get:telemetry.HeadingEvent.distance)
  return distance_;
}
inline void HeadingEvent::set_distance(float value) {
  
  distance_ = value;
  // @@protoc_insertion_point(field_set:telemetry.HeadingEvent.distance)
}

// -------------------------------------------------------------------

// Waypoint

// float longitude = 1;
inline void Waypoint::clear_longitude() {
  longitude_ = 0;
}
inline float Waypoint::longitude() const {
  // @@protoc_insertion_point(field_get:telemetry.Waypoint.longitude)
  return longitude_;
}
inline void Waypoint::set_longitude(float value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:telemetry.Waypoint.longitude)
}

// float latitude = 2;
inline void Waypoint::clear_latitude() {
  latitude_ = 0;
}
inline float Waypoint::latitude() const {
  // @@protoc_insertion_point(field_get:telemetry.Waypoint.latitude)
  return latitude_;
}
inline void Waypoint::set_latitude(float value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:telemetry.Waypoint.latitude)
}

// -------------------------------------------------------------------

// Waypoints

// repeated .telemetry.Waypoint elements = 1;
inline int Waypoints::elements_size() const {
  return elements_.size();
}
inline void Waypoints::clear_elements() {
  elements_.Clear();
}
inline const ::telemetry::Waypoint& Waypoints::elements(int index) const {
  // @@protoc_insertion_point(field_get:telemetry.Waypoints.elements)
  return elements_.Get(index);
}
inline ::telemetry::Waypoint* Waypoints::mutable_elements(int index) {
  // @@protoc_insertion_point(field_mutable:telemetry.Waypoints.elements)
  return elements_.Mutable(index);
}
inline ::telemetry::Waypoint* Waypoints::add_elements() {
  // @@protoc_insertion_point(field_add:telemetry.Waypoints.elements)
  return elements_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::telemetry::Waypoint >*
Waypoints::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:telemetry.Waypoints.elements)
  return &elements_;
}
inline const ::google::protobuf::RepeatedPtrField< ::telemetry::Waypoint >&
Waypoints::elements() const {
  // @@protoc_insertion_point(field_list:telemetry.Waypoints.elements)
  return elements_;
}

// -------------------------------------------------------------------

// NoContent

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace telemetry

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::telemetry::Priority> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry::Priority>() {
  return ::telemetry::Priority_descriptor();
}
template <> struct is_proto_enum< ::telemetry::Source> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::telemetry::Source>() {
  return ::telemetry::Source_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_telemetry_5fservice_2eproto__INCLUDED
